<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Ray Tracing Engine | Jake Taranov</title> <meta name="author" content="Jake Taranov"> <meta name="description" content="A backward ray tracing algorithm in Python"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jaketaranov.github.io/projects/1_project/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Jake </span>Taranov</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Ray Tracing Engine</h1> <p class="post-description">A backward ray tracing algorithm in Python</p> </header> <article> <p><a href="https://github.com/JakeTaranov/RayTracer" rel="external nofollow noopener" target="_blank">GitHub Repo</a></p> <p>A forward ray tracing algorithm computes the ray of lights that follow from the source of the light to the objects and ultimately to the eye (light source to eye). The drawback of this approach is due to the fact that we must compute the light rays from each light source to each of the objects in the scene, doing this is redundant as there are many rays that never come from the view plane into the eye.</p> <p>A backward ray tracing algorithm is a much more efficient approach to solving this problem. Using a backward approach we compute all the rays of light that enter the eye only (eye to light source) rather than computing all the rays of light that come from a light source (forward approach). We do this through casting rays from the eye and computing all intersections with objects and the resulting rgb color vectors from the interacting light sources, along with the diffuse and specular properties of the respected object.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/raytracer_site_2-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/raytracer_site_2-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/raytracer_site_2-1400.webp"></source> <img src="/assets/img/raytracer_site_2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="example image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/raytracer_site_3-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/raytracer_site_3-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/raytracer_site_3-1400.webp"></source> <img src="/assets/img/raytracer_site_3.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="example image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/raytracer_site-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/raytracer_site-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/raytracer_site-1400.webp"></source> <img src="/assets/img/raytracer_site.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="example image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Example output scenes. </div> <p>The low level pseudocode is as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>raytrace(ray):

    P = compute_closest_intersection(ray)
    color_local = shadow_ray(light1 , P) + ... + shawdow_ray(lightN, P)
    color_reflect = raytrace(reflected_ray)
    color = color_local + k_re * color_reflect
</code></pre></div></div> <h3 id="computing-the-closest-intersection">Computing the Closest Intersection</h3> <p>We begin computing the closest intersection by first computing the inverse transform ray.</p> \[M^{-1}\begin{pmatrix} S_x \\ S_y \\ S_z \end{pmatrix} +tM^{-1}\begin{pmatrix} c_x \\ c_y \\ c_z \end{pmatrix} = \tilde{S}' + \tilde{c}'t\] <p>Where \(M^{-1}\) is the inverse of the object, \(S_x, S_y, S_z\) are the coordinates of the ray origin, \(c_x, c_y, c_z\) is the direction of the ray, and \(t\) is a scalar value.</p> <p>Using the quadratic formula we can now determine the intersections and take the minimum value from our results using the closest intersection.</p> \[|c|^2t^2 + 2(S\cdot c)t + |S|^2 = 0\] \[At^2 + Bt + C = 0\] \[\implies\] \[t_h = -\frac{B}{A} \pm \frac{\sqrt{B^2-AC}}{A}\] \[t_h = \frac{S \cdot c}{|c|^2} \pm \frac{\sqrt{(S \cdot c)^2 - |c|^2|S|^2}}{|c|^2}\] <p>Once we find the values for \(t_h\) we must take the minimum of all values to determine the distance of the closest intersection.</p> <p>Given the closest intersection \(t_h\) we can then use this value in original untransformed ray \(S+ct\) to find the point of intersection.</p> <h3 id="computing-the-shadow-ray">Computing the Shadow Ray</h3> <p>For each closest intersection found, we now must compute the shadow rays. This is done with respect to the intersected point, we compute the closest intersections with all the light sources in the scene. Only if there is no intersection with the light sources is when we want to apply the lighting from the given source.</p> <p>In the case when there is a light source without any intersections near by we can compute the light at the given point with respect to the light source, ambient light, and specular and diffuse properties of the object the light source is projecting onto along with the light itself.</p> <p>The resulting formula comes in the form</p> \[ObjectColor{_r} = I_{a,r}K_{a,r} + I_{i,r}K_{diff,r}(N \cdot L) + I_{i,r}K_{spec,r}(R \cdot V)^n\] \[ObjectColor{_g} = I_{a,g}K_{a,g} + I_{i,g}K_{diff,g}(N \cdot L) + I_{i,g}K_{spec,g}(R \cdot V)^n\] \[ObjectColor{_b} = I_{a,b}K_{a,b} + I_{i,b}K_{diff,b}(N \cdot L) + I_{i,b}K_{spec,b}(R \cdot V)^n\] <p>Where \(I_{a,c}K_{a,c}\), \(I_{i,c}K_{diff,c}(N \cdot L)\) and \(I_{i,c}K_{spec,c}(R \cdot V)^n\) are ambient light and properties, diffuse light and properties, and specular light and properties respectively. And \(K_a\), \(K_{diff}\), \(K_{spec}\), and \(n\) are object or material properties and \(I_a\), \(I_{diff}\) and \(I_{spec}\) are properties of the light.</p> <p>\((N \cdot L)\) represents the angle between the light direction vector (\(L\)) and the surface norm (\(N\)), and \((R \cdot V)\) represents the angle between the viewer (\(V\)) and the light source reflected on the surface (\(R\)). More details on ambient light can be found <a href="http://www.conitec.net/shaders/shader_work2.htm" rel="external nofollow noopener" target="_blank">here</a>. And more details on specular light can be found <a href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model" rel="external nofollow noopener" target="_blank">here</a>.</p> <h3 id="repeat-with-reflected-rays">Repeat with Reflected Rays</h3> <p>This algorithm is inherently recursive, as for every reflected ray from as a result of an intersection we must now trace that the respected ray and compute the results it has on the final rgb values of a given pixel. We can technically have rays of light that will reflect off objects an infinite amount of times. From a pragmatic standpoint, this is very detrimental to our algorithm. In my program I have chosen to set a limit of 3 reflections per ray, I experimented with greater values but the increase in image realism does not scale linearly with the increase in run time as a result.</p> <h3 id="conclusion">Conclusion</h3> <p>This explanation of my program is not complete and I am aware of this. I simply wanted to make a brief introductory article to help explain some of the fundamental math in the program. My goals were to convey some of the main takeaways I personally found from this project, that being how we find the intersections of rays and objects, and how we calculate the rgb values at a given pixel. I hope this is enough to inspire you to learn more or just give you enough support to better understand my <a href="https://github.com/JakeTaranov/RayTracer" rel="external nofollow noopener" target="_blank">repository</a>.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Jake Taranov. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>